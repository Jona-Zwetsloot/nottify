import{EndOfStreamError as t,StreamReader as e,makeWebStreamReader as n}from"./peek-readable.js";export{AbortError,EndOfStreamError}from"./peek-readable.js";class i{constructor(t){this.numBuffer=new Uint8Array(8),this.position=0,this.onClose=t?.onClose,t?.abortSignal&&t.abortSignal.addEventListener("abort",(()=>{this.abort()}))}async readToken(e,n=this.position){const i=new Uint8Array(e.len);if(await this.readBuffer(i,{position:n})<e.len)throw new t;return e.get(i,0)}async peekToken(e,n=this.position){const i=new Uint8Array(e.len);if(await this.peekBuffer(i,{position:n})<e.len)throw new t;return e.get(i,0)}async readNumber(e){if(await this.readBuffer(this.numBuffer,{length:e.len})<e.len)throw new t;return e.get(this.numBuffer,0)}async peekNumber(e){if(await this.peekBuffer(this.numBuffer,{length:e.len})<e.len)throw new t;return e.get(this.numBuffer,0)}async ignore(t){if(void 0!==this.fileInfo.size){const e=this.fileInfo.size-this.position;if(t>e)return this.position+=e,e}return this.position+=t,t}async close(){await this.abort(),await(this.onClose?.())}normalizeOptions(t,e){if(!this.supportsRandomAccess()&&e&&void 0!==e.position&&e.position<this.position)throw new Error("`options.position` must be equal or greater than `tokenizer.position`");return{mayBeLess:!1,offset:0,length:t.length,position:this.position,...e}}abort(){return Promise.resolve()}}class r extends i{constructor(t,e){super(e),this.streamReader=t,this.fileInfo=e?.fileInfo??{}}async readBuffer(e,n){const i=this.normalizeOptions(e,n),r=i.position-this.position;if(r>0)return await this.ignore(r),this.readBuffer(e,n);if(r<0)throw new Error("`options.position` must be equal or greater than `tokenizer.position`");if(0===i.length)return 0;const s=await this.streamReader.read(e,0,i.length);if(this.position+=s,(!n||!n.mayBeLess)&&s<i.length)throw new t;return s}async peekBuffer(e,n){const i=this.normalizeOptions(e,n);let r=0;if(i.position){const t=i.position-this.position;if(t>0){const n=new Uint8Array(i.length+t);return r=await this.peekBuffer(n,{mayBeLess:i.mayBeLess}),e.set(n.subarray(t)),r-t}if(t<0)throw new Error("Cannot peek from a negative offset in a stream")}if(i.length>0){try{r=await this.streamReader.peek(e,0,i.length)}catch(e){if(n?.mayBeLess&&e instanceof t)return 0;throw e}if(!i.mayBeLess&&r<i.length)throw new t}return r}async ignore(t){const e=Math.min(256e3,t),n=new Uint8Array(e);let i=0;for(;i<t;){const r=t-i,s=await this.readBuffer(n,{length:Math.min(e,r)});if(s<0)return s;i+=s}return i}abort(){return this.streamReader.abort()}async close(){return this.streamReader.close()}supportsRandomAccess(){return!1}}class s extends i{constructor(t,e){super(e),this.uint8Array=t,this.fileInfo={...e?.fileInfo??{},size:t.length}}async readBuffer(t,e){e?.position&&(this.position=e.position);const n=await this.peekBuffer(t,e);return this.position+=n,n}async peekBuffer(e,n){const i=this.normalizeOptions(e,n),r=Math.min(this.uint8Array.length-i.position,i.length);if(!i.mayBeLess&&r<i.length)throw new t;return e.set(this.uint8Array.subarray(i.position,i.position+r)),r}close(){return super.close()}supportsRandomAccess(){return!0}setPosition(t){this.position=t}}function o(t,n){const i=new e(t),s=n??{},o=s.onClose;return s.onClose=async()=>{if(await i.close(),o)return o()},new r(i,s)}function a(t,e){const i=n(t),s=e??{},o=s.onClose;return s.onClose=async()=>{if(await i.close(),o)return o()},new r(i,s)}function f(t,e){return new s(t,e)}export{i as AbstractTokenizer,f as fromBuffer,o as fromStream,a as fromWebStream};export default null;