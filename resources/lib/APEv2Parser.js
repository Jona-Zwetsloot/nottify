import e from"./debug.js";import*as t from"./strtok3.js";import*as a from"./token-types.js";import{StringType as r}from"./token-types.js";import{uint8ArrayToString as s,stringToUint8Array as i}from"./uint8array-extras.js";const n=e=>class extends Error{constructor(t){super(t),this.name=e}};class o extends(n("UnexpectedFileContentError")){constructor(e,t){super(t),this.fileType=e}toString(){return`${this.name} (FileType: ${this.fileType}): ${this.message}`}}class l extends(n("FieldDecodingError")){}class c extends(n("InternalParserError")){}const d=e=>class extends o{constructor(t){super(e,t)}};function f(e,t,a,r){let s=t;if("utf-16le"===r){for(;0!==e[s]||0!==e[s+1];){if(s>=a)return a;s+=2}return s}for(;0!==e[s];){if(s>=a)return a;s++}return s}class p{constructor(e,t,a){this.metadata=e,this.tokenizer=t,this.options=a}}const h=/^[\x21-\x7eÂ©][\x20-\x7e\x00()]{3}/,g={len:4,get:(e,t)=>{const a=s(e.slice(t,t+g.len),"latin1");if(!a.match(h))throw new l(`FourCC contains invalid characters: ${function(e){const t=[];for(let a=0,r=e.length;a<r;a++){const r=Number(e.charCodeAt(a)).toString(16);t.push(1===r.length?`0${r}`:r)}return t.join(" ")}(a)} "${a}"`);return a},put:(e,t,a)=>{const r=i(a);if(4!==r.length)throw new c("Invalid length");return e.set(r,t),t+4}};var m;!function(e){e[e.text_utf8=0]="text_utf8",e[e.binary=1]="binary",e[e.external_info=2]="external_info",e[e.reserved=3]="reserved"}(m||(m={}));const u={len:52,get:(e,t)=>({ID:g.get(e,t),version:a.UINT32_LE.get(e,t+4)/1e3,descriptorBytes:a.UINT32_LE.get(e,t+8),headerBytes:a.UINT32_LE.get(e,t+12),seekTableBytes:a.UINT32_LE.get(e,t+16),headerDataBytes:a.UINT32_LE.get(e,t+20),apeFrameDataBytes:a.UINT32_LE.get(e,t+24),apeFrameDataBytesHigh:a.UINT32_LE.get(e,t+28),terminatingDataBytes:a.UINT32_LE.get(e,t+32),fileMD5:new a.Uint8ArrayType(16).get(e,t+36)})},k={len:24,get:(e,t)=>({compressionLevel:a.UINT16_LE.get(e,t),formatFlags:a.UINT16_LE.get(e,t+2),blocksPerFrame:a.UINT32_LE.get(e,t+4),finalFrameBlocks:a.UINT32_LE.get(e,t+8),totalFrames:a.UINT32_LE.get(e,t+12),bitsPerSample:a.UINT16_LE.get(e,t+16),channel:a.UINT16_LE.get(e,t+18),sampleRate:a.UINT32_LE.get(e,t+20)})},T={len:32,get:(e,t)=>({ID:new a.StringType(8,"ascii").get(e,t),version:a.UINT32_LE.get(e,t+8),size:a.UINT32_LE.get(e,t+12),fields:a.UINT32_LE.get(e,t+16),flags:E(a.UINT32_LE.get(e,t+20))})},y={len:8,get:(e,t)=>({size:a.UINT32_LE.get(e,t),flags:E(a.UINT32_LE.get(e,t+4))})};function E(e){return{containsHeader:w(e,31),containsFooter:w(e,30),isHeader:w(e,29),readOnly:w(e,0),dataType:(6&e)>>1}}function w(e,t){return!!(e&1<<t)}const z=e("music-metadata:parser:APEv2"),I="APEv2",U="APETAGEX";class x extends(d("APEv2")){}class A extends p{constructor(){super(...arguments),this.ape={}}static tryParseApeHeader(e,t,a){return new A(e,t,a).tryParseApeHeader()}static calculateDuration(e){let t=e.totalFrames>1?e.blocksPerFrame*(e.totalFrames-1):0;return t+=e.finalFrameBlocks,t/e.sampleRate}static async findApeFooterOffset(e,t){const a=new Uint8Array(T.len),r=e.position;await e.readBuffer(a,{position:t-T.len}),e.setPosition(r);const s=T.get(a,0);if("APETAGEX"===s.ID)return s.flags.isHeader?z("APE Header found at offset="+(t-T.len)):(z("APE Footer found at offset="+(t-T.len)),t-=s.size),{footer:s,offset:t}}static parseTagFooter(e,a,r){const s=T.get(a,a.length-T.len);if(s.ID!==U)throw new x("Unexpected APEv2 Footer ID preamble value");t.fromBuffer(a);return new A(e,t.fromBuffer(a),r).parseTags(s)}async tryParseApeHeader(){if(this.tokenizer.fileInfo.size&&this.tokenizer.fileInfo.size-this.tokenizer.position<T.len)return void z("No APEv2 header found, end-of-file reached");const e=await this.tokenizer.peekToken(T);if(e.ID===U)return await this.tokenizer.ignore(T.len),this.parseTags(e);if(z(`APEv2 header not found at offset=${this.tokenizer.position}`),this.tokenizer.fileInfo.size){const e=this.tokenizer.fileInfo.size-this.tokenizer.position,t=new Uint8Array(e);return await this.tokenizer.readBuffer(t),A.parseTagFooter(this.metadata,t,this.options)}}async parse(){const e=await this.tokenizer.readToken(u);if("MAC "!==e.ID)throw new x("Unexpected descriptor ID");this.ape.descriptor=e;const t=e.descriptorBytes-u.len,a=await(t>0?this.parseDescriptorExpansion(t):this.parseHeader());return await this.tokenizer.ignore(a.forwardBytes),this.tryParseApeHeader()}async parseTags(e){const t=new Uint8Array(256);let a=e.size-T.len;z(`Parse APE tags at offset=${this.tokenizer.position}, size=${a}`);for(let i=0;i<e.fields;i++){if(a<y.len){this.metadata.addWarning(`APEv2 Tag-header: ${e.fields-i} items remaining, but no more tag data to read.`);break}const n=await this.tokenizer.readToken(y);a-=y.len+n.size,await this.tokenizer.peekBuffer(t,{length:Math.min(t.length,a)});let o=f(t,0,t.length);const l=await this.tokenizer.readToken(new r(o,"ascii"));switch(await this.tokenizer.ignore(1),a-=l.length+1,n.flags.dataType){case m.text_utf8:{const e=(await this.tokenizer.readToken(new r(n.size,"utf8"))).split(/\x00/g);await Promise.all(e.map((e=>this.metadata.addTag(I,l,e))));break}case m.binary:if(this.options.skipCovers)await this.tokenizer.ignore(n.size);else{const e=new Uint8Array(n.size);await this.tokenizer.readBuffer(e),o=f(e,0,e.length);const t=s(e.slice(0,o)),a=e.slice(o+1);await this.metadata.addTag(I,l,{description:t,data:a})}break;case m.external_info:z(`Ignore external info ${l}`),await this.tokenizer.ignore(n.size);break;case m.reserved:z(`Ignore external info ${l}`),this.metadata.addWarning(`APEv2 header declares a reserved datatype for "${l}"`),await this.tokenizer.ignore(n.size)}}}async parseDescriptorExpansion(e){return await this.tokenizer.ignore(e),this.parseHeader()}async parseHeader(){const e=await this.tokenizer.readToken(k);if(this.metadata.setFormat("lossless",!0),this.metadata.setFormat("container","Monkey's Audio"),this.metadata.setFormat("bitsPerSample",e.bitsPerSample),this.metadata.setFormat("sampleRate",e.sampleRate),this.metadata.setFormat("numberOfChannels",e.channel),this.metadata.setFormat("duration",A.calculateDuration(e)),!this.ape.descriptor)throw new x("Missing APE descriptor");return{forwardBytes:this.ape.descriptor.seekTableBytes+this.ape.descriptor.headerDataBytes+this.ape.descriptor.apeFrameDataBytes+this.ape.descriptor.terminatingDataBytes}}}export{A as APEv2Parser,x as ApeContentError};export default null;