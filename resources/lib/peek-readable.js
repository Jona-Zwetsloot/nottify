class e extends Error{constructor(){super("End-Of-Stream"),this.name="EndOfStreamError"}}class r extends Error{constructor(e="The operation was aborted"){super(e),this.name="AbortError"}}class t{constructor(){this.resolve=()=>null,this.reject=()=>null,this.promise=new Promise(((e,r)=>{this.reject=r,this.resolve=e}))}}class s{constructor(){this.maxStreamReadSize=1048576,this.endOfStream=!1,this.interrupted=!1,this.peekQueue=[]}async peek(e,r,t){const s=await this.read(e,r,t);return this.peekQueue.push(e.subarray(r,r+s)),s}async read(r,t,s){if(0===s)return 0;let a=this.readFromPeekBuffer(r,t,s);if(a+=await this.readRemainderFromStream(r,t+a,s-a),0===a)throw new e;return a}readFromPeekBuffer(e,r,t){let s=t,a=0;for(;this.peekQueue.length>0&&s>0;){const t=this.peekQueue.pop();if(!t)throw new Error("peekData should be defined");const n=Math.min(t.length,s);e.set(t.subarray(0,n),r+a),a+=n,s-=n,n<t.length&&this.peekQueue.push(t.subarray(n))}return a}async readRemainderFromStream(e,t,s){let a=s,n=0;for(;a>0&&!this.endOfStream;){const s=Math.min(a,this.maxStreamReadSize);if(this.interrupted)throw new r;const i=await this.readFromStream(e,t+n,s);if(0===i)break;n+=i,a-=i}return n}}class a extends s{constructor(e){if(super(),this.s=e,this.deferred=null,!e.read||!e.once)throw new Error("Expected an instance of stream.Readable");this.s.once("end",(()=>{this.endOfStream=!0,this.deferred&&this.deferred.resolve(0)})),this.s.once("error",(e=>this.reject(e))),this.s.once("close",(()=>this.abort()))}async readFromStream(e,r,s){const a=this.s.read(s);if(a)return e.set(a,r),a.length;const n={buffer:e,offset:r,length:s,deferred:new t};return this.deferred=n.deferred,this.s.once("readable",(()=>{this.readDeferred(n)})),n.deferred.promise}readDeferred(e){const r=this.s.read(e.length);r?(e.buffer.set(r,e.offset),e.deferred.resolve(r.length),this.deferred=null):this.s.once("readable",(()=>{this.readDeferred(e)}))}reject(e){this.interrupted=!0,this.deferred&&(this.deferred.reject(e),this.deferred=null)}async abort(){this.reject(new r)}async close(){return this.abort()}}class n extends s{constructor(e){super(),this.reader=e}async readFromStream(e,r,t){const s=await this.reader.read(new Uint8Array(t));return s.done&&(this.endOfStream=s.done),s.value?(e.set(s.value,r),s.value.byteLength):0}abort(){return this.reader.cancel()}async close(){await this.abort(),this.reader.releaseLock()}}class i extends s{constructor(e){super(),this.reader=e,this.buffer=null,this.bufferOffset=0}async readFromStream(r,t,s){let a=0;if(this.buffer){const e=this.buffer.byteLength-this.bufferOffset,n=Math.min(e,s);r.set(this.buffer.subarray(this.bufferOffset,this.bufferOffset+n),t),this.bufferOffset+=n,a+=n,s-=n,t+=n,this.bufferOffset>=this.buffer.byteLength&&(this.buffer=null,this.bufferOffset=0)}for(;s>0&&!this.endOfStream;){const e=await this.reader.read();if(e.done){this.endOfStream=!0;break}if(e.value){const n=e.value;if(n.byteLength>s)return r.set(n.subarray(0,s),t),this.buffer=n,this.bufferOffset=s,a+=s,a;r.set(n,t),a+=n.byteLength,s-=n.byteLength,t+=n.byteLength}}if(0===a&&this.endOfStream)throw new e;return a}abort(){return this.interrupted=!0,this.reader.cancel()}async close(){await this.abort(),this.reader.releaseLock()}}function f(e){try{const r=e.getReader({mode:"byob"});return r instanceof ReadableStreamDefaultReader?new i(r):new n(r)}catch(r){if(r instanceof TypeError)return new i(e.getReader());throw r}}export{r as AbortError,e as EndOfStreamError,a as StreamReader,n as WebStreamByobReader,i as WebStreamDefaultReader,f as makeWebStreamReader};export default null;